---
name: 📝 리뷰 과제
about: 4, 5장 ML 시스템 설계
title: '[Week 3] 주차 리뷰 - 최예지'
labels: ['review']
assignees: ''
---

## 주제
<!-- 이번 주차에 다룬 주요 주제를 작성해주세요 -->
- 추천시스템 접목 실제 예시 (넷플릭스)
- 추천시스템의 전체 설계 과정

## 내용
<!-- 주요 개념과 내용을 정리해주세요 -->

![image](https://github.com/user-attachments/assets/0330586a-9c13-4690-bfbf-9945a6513d74)

![image](https://github.com/user-attachments/assets/be8ff230-9c5e-4c0b-85dd-4b08c61fc411)


### **1. 감성기반 영화 추천 서비스 및 시스템: the case of Netflix**

   #### **[전통적 추천 시스템 - 협업 필터링]**
   
   : 많은 사용자로부터 선호도 또는 취향 정보를 수집하여(협업), 사용자의 관심에 대한 자동 예측(필터링)을 수행하는 기법
   - 사용자와 아이템 간의 유사성을 이용해 개인화된 추천을 제공
   - 비슷한 선호도를 가진 사용자들 간에 경험을 공유하여 추천 품목을 에측
   - e.g. 사용자 A와 B가 과거에 비슷한 영화를 좋아했다면, A가 아직 보지 않은 B의 영화를 A에게 추천
   - 크게 사용자 기반 협업 필터링(User-based Collaborative Filtering), 아이템 기반 협업 필터링(Item-based Collaborative Filtering)으로 나뉨
  
   a. **사용자 기반 협업 필터링** 동작 원리
   - 나와 비슷한 취향을 가진 다른 사용자들이 좋아하는 항목을 추천
   - step 1) 해당 사용자가 이전까지 기록한 평가 점수들을 이용하여, 다른 사용자들과의 유사도를 측정
   - step 2) 다른 사용자들과의 유사도를 바탕으로, 목표 영화에 점수를 부여한 사용자 중 해당 사용자와의 유사도가 큰 k명을 선택하고, 이들을 "이웃(neighbor)"이라고 정의
   - step 3) 이웃들 과의 유사도와 이웃들이 목표 여오하에 준 평가점수를 이용하여, 목표 사용자들의 평가 점수를 예측

   b. **아이템 기반 협업 필터링** 동작 원리
   - 내가 좋아하는 아이템과 유사한 아이템을 찾아 추천
   - step 1) 유사한 특성을 가진 아이템을 그룹화하고
   - step 2) 내가 이전에 선호한 아이템과 유사한 항목을 추천

   c. 협업 필터링의 장/단점
   - 장점) 데이터에 의존하므로 별도의 도메인 지식이 없어도 추천이 가능하며, 정확도가 높은 편이다
   - 단점)
     - 콜드 스타트 문제(Cold Start Problem): 새로운 사용자나 아이템에 대한 데이터가 없으면 추천이 어려움
     - 희소성 문제: 사용자-아이템 간의 행렬이 희소할 경우 정확한 유사도를 계산하기 어려움 
  
   #### **[넷플릭스 알고리즘 - Cine-match algorithm]**
   넷플릭스의 초기 추천 시스템의 Cinematch는 사용자 평점 예측에 최적화된 알고리즘으로,
   행력 분해, 베이지안 확률 모델 및 연관 분석 같은 전통적 기법을 협업 필터링과 결합한 형식으로 설계되었다.
   그러나 시간이 지나면서 넷플릭스는 이러한 알고리즘을 신경망 기반의 하이브리드 추천 시스템으로 확장시켰다.
   
   - 수식
   ![image](https://github.com/user-attachments/assets/ab85e146-9e11-4ec7-a6b8-de6a30b7c5b4)
   - 구성
   ![image](https://github.com/user-attachments/assets/2e62cbe6-6d90-449a-a978-f9e8a4f63125)
   (출처: https://www.slideshare.net/slideshow/4-151106-58384116/58384116)
   
   **a. 베이지안 분류 (Bayesian Classifier)**
   - 확률적 추론 모델 사용
   - 베이즈 정리 수식
     
     ![image](https://github.com/user-attachments/assets/202bc99d-e487-479b-b8b6-a3635924e9fc)
     
   - 응용 방법
     - A를 사용자가 영화 x를 좋아할 확률, B를 영화의 메타데이터/사용자 평점/유사 사용자 집단 데이터로 잡는다
     - P(A|B)는 사용자가 영화 x를 좋아할 확률

       -> 베이즈 정리를 이용해, 영화에 대한 정보와 사용자의 과거 행동 데이터를 결합해서 특정 영화를 추천할지 여부를 결정
       -> P(A|B)를 계산하는 것이 최종 목표
     - P(B|A)는 사용자가 과거에 비슷한 영화를 좋아했을 때 비슷한 영화가 추천될 가능성

       -> 영화의 장르, 배우, 감독, 평점과 같은 메타데이터 기반으로 추정됨
        
   **b. 연관 분석 (Association analysis)**

   데이터에서 항목 간의 연관성(관계)을 찾기 위해 사용되는 데이터 마이닝 기법. 
   주로 장바구니 분석(Market Basket Analysis)에서 시작된 개념으로, 한 항목이 선택될 때 다른 항목이 함께 선택될 가능성을 찾는 데 사용됨
   - 패턴 감지 능력
   - 연관 규칙: "만약 A가 발생하면 B도 발생한다"는 형태로 표현
   - 수학적 정의
     
     ![image](https://github.com/user-attachments/assets/023c92c6-8844-4d28-a212-553e91169ffc)

   - 응용 방법
     - 사용자가 특정 영화나 시리즈와 함께 시청하는 콘텐츠 분석할 때 사용
     - 특정 배우가 나오는 영화를 좋아하는 사용자가 다른 배우의 영화도 선호하는지 탐색

   **c. 신경망 학습 (Neural Network)**
   - 행렬 분해
   - Cinematch의 수식을 살펴보면, 사용자와 아이템 간의 관계는 잠재 특성 벡터 Pu와 Qi로 표현된다.
     이는 행렬 분해(Matrix Factorization)를 통해 학습되는 방식인데, 신경망은 이 과정을 더욱 정교하게 확장시킬 수 있음
     - 기존) 사용자의 선호도 Pu와 영화의 특징 Qi를 내적으로 계산
     - 신경망) 사용자의 선호도 Pu와 영화의 특징 Qi를 비선형 변환을 통해 학습
   - 입력으로 사용자와 아이템의 정보를 받아 잠재 벡터를 자동으로 학습하고, 이를 기반으로 예상 평점 또는 추천 확률 출력
     
### **2. 추천시스템의 아키텍쳐** 

**[깔때기 접근 방식]**

대규모 콘텐츠 데이터에서 사용자가 선호할 가능성이 높은 소수의 아이템을 선택하는 과정

![image](https://github.com/user-attachments/assets/761bb73b-3f45-46eb-b302-e561bb296fa8)

후보 생성 -> 필터링 -> 랭킹

각 단계가 점진적으로 콘텐츠를 좁히면서 최종 추천 결과를 도출

a. **후보생성**

방대한 콘텐츠 카탈로그를 순위를 매길 훨씬 더 작은 후보 그룹으로 줄이는 것
- 유튜브용 후보 생성기는 수십억 개의 카탈로그에서 수백, 수천 개의 잠재적 후보를 생성함 -> 이 단계에서 다양한 알고리즘이 활용됨. "selection"
- 알고리즘
  - **"네거티브 샘플링"** 기법 사용
  - 관련 없는 아이템들이 하위 집합을 선택해서 음성 예로 사용
  - 목표) 음성 아이템을 대표할 수 있는 샘플을 만들어서 학습 절차를 최적화
- **후보 생성 알고리즘**
  - 이웃 기반 방법 (User-based CF): 아이템에 대한 사용자의 선호도 차이나 다른 사용자의 선호도를 활용해 후보를 생성
    (사용자 기반 협업 필터링, 아이템 기반 협업 필터링)
  - 그래프 기반 방법 (Graph-based Methods): 사용자가 아이템과 연결된 네트워크를 그래프로 표현하여 추천을 생
  - 잠재 방법 (Latent Factor Models): 행렬 분해와 심층 신경망(DNN) 같은 알고리즘을 사용해 숨겨진 사용자 및 아이템의 특징을 모델링함
- **임베딩 기술**

  사용자와 아이템의 특징을 저차원 벡터로 표현하는 것. 이 벡터는 추천 시스템이 사용자와 아이템의 잠재적 유사도를 계산할 때 사용됨
  - **행렬 분해(Matrix Factorization)**

    사용자와 아이템에 대한 평점으로 구성 하나의 행렬을 분해하는 방식 (e.g. SVD)

    ![image](https://github.com/user-attachments/assets/bae9a9e0-3f3e-4f4c-be72-37963daa16f8)

    SVD의 경우, 고차원 행렬을 저차원 행렬로 축소하고, 축소한 저차원 행렬을 다시 원래의 행렬로 복원하는 과정을 통해 초기 행렬을 복원한다.
    이러한 과정을 통해 추천 대상 사용자가 평점을 부여하지 않은 제품 및 서비스에 대한 평점을 예측할 수 있다.
  - **심층 신경망(DNN)**
 
    사용자 리뷰 텍스트, 이미지 등 다양한 정보를 모델에 적용하기 위한 모델들이 연구되고 있다. (e.g. NeuMF 모델)

    ![image](https://github.com/user-attachments/assets/db7a0e90-5bb5-4b3e-a36e-a650c41e8db1)

    NeuMF 모델은 행렬 분해와 신경망을 결합한 모델로, 유저와 아이템의 one-hot vector(하나의 요소만 1이고 나머지는 모두 0인 벡터)를 밀집 행렬로 임베딩하여 뉴럴 네트워크 연산을 통해 구매 여부를 예측한다.
    유저와 아이템의 암묵적인 상호작용을 분석하고, 정교하게 예측한다는 점에서 비선형 관계까지 학습하는 것을 볼 수 있다.

  - **그래프 임베딩(Graph Embedding)**
 
    대규모 네트워크의 노드를 컴펙트한 저차원 표현으로 변환하는 기술 (e.g. GNN). 네트워크 임베딩이라고도 부름
 
    대부분 유저와 아이템간의 관계는 본질적으로 그래프 구조로 표현될 수 있다.
 
    ![image](https://github.com/user-attachments/assets/75532de7-e15c-4c72-a468-ac4d96916851)

    GNN(Graph Neural Networks)는 딥러닝을 활용해 그래프 구조적 정보를 동적으로 학습하고 임베딩 벡터로 변환하는 대표적인 방법이다.
    그래프 내 각 노드의 특징과 그 이웃 노드의 정보를 집계하고 갱신하면서 노드 간 관계를 학습한다.

b. **필터**

후보로 선정된 수많은 아이템 중에서 사용자에게 가장 적합한 소수의 아이템만 선별하는 과정

- 대규모 추천 시스템의 후보 스코어링
  : 대규모 추천 시스템에서 모든 잠재적 추천 후보의 점수를 실시간으로 매기기는 불가능한 경우가 많음
  -> 이때 사용하는 기법: 근사 근접 이웃
- **근사 근접 이웃(Approximous Nearest Neighbors, ANN)**
  - 각 사용자에 대한 최선의 후보를 효율적으로 찾음 (정확한 거리를 구하지 않고, 근사적으로 가장 가까운 이웃을 찾음)
  - 점간 거리를 근사화해 고차원 공간을 효율적으로 검색
  - 유클리디안 거리, 코사인 유사도 등의 계산이 고차원 공간에서는 비효율적임. 따라서 해시, 양자화, 그래프 탐색 등의 기법을 통해 속도를 높임
  - **국소성 민감 해싱(Locality Sensitive Hashing, LSH)**

    -> 해싱(Hashing): 어떤 데이터를 입력해서 고정된 크기의 고유한 코드로 변환하는 것. 해시값은 원래 데이터를 특정한 위치에 저장하거나 검색할 때 사용됨
    -> 방법: 고차원 공간을 여러 개의 해시 테이블로 나누고, 쿼리 벡터와 유사한 벡터가 있는 해시 버킷만 빠르게 검색해 효율적으로 근접 이웃을 찾음 
  - **제품 양자화 파일 역인덱스(Inverted File Index with Product Quantization, IVFPQ)**

    -> 방법: 고차원 벡터를 여러 개의 작은 서브 벡터로 나누고 각 서브 벡터를 양자화하여 근사값으로 검색하는 방법
  - **HNSW(Hierarchical Navigable Small World)**
  
    -> 그래프 기반 탐색 방법
    -> 데이터 포인트를 계층적으로 연결된 그래프로 구성한 다음, 상위 계층에서 시작하여 점점 하위 계층으로 이동하여 이웃을 좁혀간다. 그리고 가장 가까운 이웃 노드를 찾을 때까지 그래프를 탐색함

c. **사전 랭킹(Pre-Ranking)**

전체 후보 아이템 중 가장 유망한 소수의 후보들을 빠르게 선별하는 과정

- 모델: "지식 증류(Knowledge Distillation)" 기법 사용
  - 최근 기계학습에서 활발하게 연구되고 있는 모델 압축 기법 중의 하나
  - 학습 용량이 큰 대형 모델을 활용하여 작고 빠른 소형 모델을 학습시키는 기술

    ![image](https://github.com/user-attachments/assets/7d0d8c34-62a8-4890-9b2d-b821eb0c63a1)

  - 먼저, 선생 추천 모델이 예측한 사용자-아이템 상에 대한 연관 점수를 학생 모델에게 학습시킴
  - 임의의 사용자-아이템 상에 대한 선생 모델의 출력 점수를 소프트 레이블로 사용하여 선호도를 학
- 휴리스틱 모델에서부터 시작하여 경량 DNN까지 발전함

d. **헤비 랭킹 (전체 랭킹)**

다양한 유저, 아이템, 컨텍스트 정보를 결합하여 사전 랭킹에서 선별된 후보들을 최종적으로 정렬하는 과정.
- 하나의 아이템에 대해 rank를 산출하는 것
- **로제스틱 회귀 알고리즘**
- **그래디언트 부스팅 알고리즘**
  - 여러 약한 예측 모델들 (주로 결정 트리)을 순차적으로결 결합하여 최종적인 강한 예측 모델을 만드는 방법
  - 예측 오차(잔차)를 반복적으로 줄여가는 과정에서 점진적으로 성능 개선
  - 초기 학습기(보통 깊이가 낮은 결정 트리)를 학습시켜 초기 예측값 생성 -> 잔차 계산 -> 잔차를 학습하는 새로운 트리 생성 -> 각 트리의 가중치 조정 -> 예측값 업데이트 -> 반복
- **하이브리드 알고리즘**
  - 한동안 부스팅 트리와 로지스틱 회귀가 추천 시스템에서 함께 사용됨
  - 부스팅 트리 -> 피처 간의 복잡한 비선형 관계를 포착
  - 부스팅 트리에서 파생된 피처를 선형 분류기에 입력 -> 해당 경로에 해당하는 가중치 학습
- **심층 신경망 DNN**
  - 최근 업계에서 포인트별 랭킹 모델 알고리즘으로 DNN을 가장 많이 사용함
  - 성능 포화 없이 방대한 데이터 처리 가능, 특정 문제 도메인에 맞게 조정 가능 -> 광범위한 작업에서 다른 ML 알고리즘 능가
  
e. **리랭킹 (Re-Ranking)**

헤비 랭킹 후 최종적으로 후보 아이템의 순서를 다시 최적화하는 과정
- 지속적으로 운영하고 있는 서비스라서 유저의 피드백이 실시간으로 인입되고 있는 구조일 때 필요한 단계
- 최종 선택된 아이템들 간의 재정렬
- 이때, 대표적으로 "정확도", "다양성(re-ranking 된 리스트가 얼마나 다른지, topic coverage)", "공평성(아이템이 일정한 수준의 노출량을 보장받는 것)" objective를 놓고 고려
- 최신 논문일수록 Recurrent -> RNN & Self-attention -> Self-attention 중심으로 옮겨지고 있음

  
## 참고 자료
<!-- 주요 개념과 내용을 정리해주세요 -->
- 노연정. (2018-12-19). 감성기반 영화 추천 서비스 및 시스템 연구 - 넷플릭스를 중심으로. 한국정보과학회 학술발표논문집, 강원.
- Carlos A. Gomez-Uribe and Neil Hunt. 2016. The Netflix Recommender System: Algorithms, Business Value, and Innovation. ACM Trans. Manage. Inf. Syst. 6, 4, Article 13 (January 2016), 19 pages. https://doi.org/10.1145/2843948
- https://www-dbpia-co-kr-ssl.openlink.khu.ac.kr/journal/articleDetail?nodeId=NODE10536744
- https://thingsolver.com/blog/introduction-to-recommender-systems/
- https://ysg2997.tistory.com/24
